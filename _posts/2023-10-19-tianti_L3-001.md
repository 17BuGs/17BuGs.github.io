---
redirect_from: /_posts/2023-10-19-tianti_L3-001
title: 天梯赛_L2-033
tags: 算法竞赛
---

## 团体程序设计天梯赛

#### L3-001 凑零钱

两种做法。

法一：dfs+剪枝。这种做法在最后一个测试点会超时，最后一个测试点对应的情况是所有的零钱加起来都不能满足要求，单独判断这种情况可AC. 这种做法的步骤是，首先读取零钱数据，同时加和，读取完成后判断和是否小于题目所要求的值，是则直接输出结果。否则，对存储零钱的数组排序，接着dfs，在这个过程中实时同步存储结果的数组`res`和存储当前零钱总和的变量`sum`，如果出现加上某个节点的值的结果大于所要求的值时，说明这之后搜索的值也都大于该值，所以可以剪枝；如果小于所要求的值时，还没有搜索到`val`数组（顺序存储零钱的数组）的最后一个值，则递归搜索其儿子节点，反之说明其父节点所引出的所有节点已经必然小于所要求的值了，进行剪枝。

```cpp
#include <bits/stdc++.h>
using namespace std;
vector<int> val, res;
int n, m, flag = 0, sum = 0;
void dfs(int node){
    sum += val[node];
    res.push_back(val[node]);
    if(sum == m){
        for(int i = 0; i <= (int)res.size() - 1; i++)
            cout << res[i] << " \n"[i == (int)res.size() - 1];
        flag = 1;
        return;
    }
    else if(sum > m){
        res.pop_back();
        sum -= val[node];
        return;
    }
    else{
        if(node == n - 1){
            res.pop_back();
            sum -= val[node];
            return;
        }
        dfs(node + 1);
        if(flag) return;
        else{
            res.pop_back();
            sum -= val[node];
            dfs(node + 1);
        }
    }
}
int main(){
    cin >> n >> m;
    val.resize(n);
    int preSum = 0;
    for(int i = 0; i <= n - 1; i++){
        cin >> val[i];
        preSum += val[i];
    }
    if(preSum < m) cout << "No Solution" << endl;
    else{
        sort(val.begin(), val.end());
        dfs(0);
        if(!flag) cout << "No Solution" << endl;
    }
    return 0;
}
```

法二：dp，0/1背包问题。待更新...