---
redirect_from: /_posts/compiling_fundamentals
title: 编译原理复习
tags: CS专业课
---

####  目录

- [目录](#目录)
- [绪论](#绪论)
- [文法与语言](#文法与语言)
- [词法分析](#词法分析)
- [自上而下语法分析](#自上而下语法分析)



#### 绪论

1. 程序的翻译通常有两种方式：**编译**和**解释**。
2. 编译程序的功能是将高级语言源程序编译成目标程序，完成**高级语言程序**到**低级语言程序**的等价翻译。
3. 编译程序绝大多数时间花在**表格管理**上。
4. 编译程序的工作过程：词法分析、语法分析、语义分析、中间代码生成、代码优化、目标代码生成。前三者为分析部分，后三者为综合部分。
![image](/assets/images/compiler/compile_struct.png)
5. 一遍（趟）翻译与多遍（趟）翻译。若某语言允许变量先使用后定义，则应采用**多遍翻译**。
- 多遍翻译：
![image](/assets/images/compiler/multicomp.png)
- 一遍翻译：
![image](/assets/images/compiler/oncecomp.png)

#### 文法与语言

1. 句型：语法树的叶子从左到右；
   
   短语：语法树中每棵子树的叶子从左到右；
   
   直接短语：每棵简单子树（只有父子两层的子树）的叶子从左到右；
   
   句柄：最左边简单子树的叶子从左到右；
   
   素短语：至少包含一个终结符，且不包含其他素短语的短语；
   
   最左素短语：语法树最左边的素短语。
2. 句型是文法开始符号的广义推导，仅仅由终结符组成的句型叫句子。文法所定义的语言是一个文法中所有**句子**的集合。
3. 对于**无二义文法**的句型，其句柄是唯一的（对于一个任意的文法，其句柄可能是不唯一的）。
4. 如果一个文法存在某个句子，对应两棵不同的语法树，那么该文法二义。
5. 不存在一个算法，可以在有限步骤内确切判定一个文法是否二义，即，文法的二义性是**不可判定的**。
6. 四种文法所对应的语言之间的关系：$L3 \subseteq L2 \subseteq L1 \subseteq L0$.
   - 0型文法：无限制文法；
   - 1型文法：每个产生式满足$\alpha A \beta \rightarrow \alpha \mu \beta$，其中$A$为非终结符，$\mu$不为空；
   - 2型文法：每个产生式满足$A \rightarrow \beta$，其中$A$为非终结符；
   - 3型文法：每个产生式有$A \rightarrow \alpha B$、$A \rightarrow \alpha$的形式（右线性文法），或者$A \rightarrow B \alpha$、$A \rightarrow \alpha$的形式（左线性文法），其中$A$、$B$为非终结符，$\alpha$为空或终结符串。
7. 文法的化简：
   - 形如$A \rightarrow A$的产生式；
   - 无用非终结符（维护一个可以推导出终结符号串的非终结符号的集合$Q$，逐步扩大这个集合，直到不能更大）；
   - 不可达文法符号（维护可达符号集$R$和产生式集合$L$，$L$初始包含所有开始符号的产生式。逐步将可达符号加入符号集$R$，并标记所取的产生式，将产生式右部的非终结符对应的产生式加入产生式集合$L$，直到$L$为空或只含有标记过的产生式）。

#### 词法分析

1. 词法分析根据变换时扫描源程序的次数，分为**一次扫描式**和**多次扫描式**。
   - 一次扫描式：将字符串表示的源程序，经词法分析以后，得到一个个单词系列，再作语法分析。

   <div align=center>
   <img src="/assets/images/compiler/oncescan.png" width = "60%"/>
   </div>

   - 多次扫描式：将字符串表示的源程序，经词法分析以后，得到一个单词符号，立即作语法分析，再取下一个单词...

   <div align=center>
   <img src="/assets/images/compiler/multiscan.png" width = "50%"/>
   </div>

2. 词法分析器的输入是**字符串表示的源程序**，输出是**单词符号序列**。
3. 词法分析器的设计过程：

   <div align=center>
   <img src="/assets/images/compiler/cifadesign.png" width = "40%"/>
   </div>

4. DFA和NFA：
   - DFA：确定的有穷自动机。$M=(S, \Sigma, f, S_0, F)$. 
     - $S$：状态的有穷非空集；
     - $\Sigma$：有穷输入字母表；
     - $f$：状态转换函数，单值映射；
     - $S_0 \in S$：唯一的初始状态，非空；
     - $F \in S$：终态集，可以为空。
   - NFA：非确定的有穷自动机。$M=(S, \Sigma, f, S_0, F)$.
     - $S$：状态的有穷非空集；
     - $\Sigma$：有穷输入字母表；
     - $f$：状态转换函数，多值映射，允许空移；
     - $S_0 \in S$：初态集，非空，初始状态不唯一；
     - $F \in S$：终态集，可以为空。

   <div align=center>
   <img src="/assets/images/compiler/dfa_nfa.png" width = "60%"/>
   </div>

5. 若正规式$R1$与$R2$描述的正规集相同，则$R1$与$R2$等价。

   <div align=center>
   <img src="/assets/images/compiler/zgs_zgj.png" width = "60%"/>
   </div>

6. 正规式$R \rightarrow NFA$：**分裂法**。引进一个初态结点$x$和终态结点$y$.

   <div align=center>
   <img src="/assets/images/compiler/r2nfa_1.png" width = "30%"/>
   </div>
   <div align=center>
   <img src="/assets/images/compiler/r2nfa.png" width = "60%"/>
   </div>

7. $NFA \rightarrow DFA$：**子集法**。从$\epsilon -closure(x)$开始，求集合$I_a$，造表；再画状态转换表（只要含有$x$即为初态，只要含有$y$即为终态）；画状态转换图（$DFA$）。
8. 最小化$DFA$：**分划法**（分割法）找等价状态。
9. 右线性正规文法$\rightarrow$有穷自动机：
   
   已知文法$G[S]=(V_N, V_T, S, P)$，增加一个状态$D$表示终止，则$FSA~M=(Q, \Sigma, q_0, f, F)$. 其中，
   - $Q=V_N \cup D$，$D \notin V_N$；
   - $\Sigma = V_T$；
   - $q_0 = S$；
   - $F = \{D\}$.

   若$A \rightarrow aB$，则有$f(A, a) = B$；

   若$A \rightarrow a$，则有$f(A, a)=D$；

   若$A \rightarrow \epsilon$，则有$f(A, \epsilon)=D$.

10. 左线性正规文法$\rightarrow$有穷自动机：
    
    已知文法$G[S]=(V_N, V_T, S, P)$，增加一个状态$q_0$表示初态，则$FSA~M=(Q, \Sigma, q_0, f, F)$. 其中，
    - $Q=V_N \cup \{q_0\}$，$D \notin V_N$；
    - $\Sigma = V_T$；
    - $F = \{S\}$.

    若$A \rightarrow Ba$，则有$f(B, a) = A$；

    若$A \rightarrow a$，则有$f(q_0, a)=A$.

11. 自动机$\rightarrow$正规式：**消结法**。引进两个状态$x$，$y$，表示初态和终态。消结规则：

   <div align=center>
   <img src="/assets/images/compiler/xiaojierule.png" width = "80%"/>
   </div>

12. 有穷自动机$\rightarrow$正规文法：
    
    已知$FSA~M = (Q, \Sigma, q_0, f, F)$，求$G = (V_N, V_T, S, P)$

    - 令：$V_N = Q$，$V_T = \Sigma$，$S = \{q_0\}$；
    - 由映射函数来构造规则式：若$f(A, a)=B$，则令$A \rightarrow aB$；若$B$是终态，则令$B \rightarrow \epsilon$.
    
#### 自上而下语法分析

1. $First/Follow/Secect$集合