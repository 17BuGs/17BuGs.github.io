---
redirect_from: /_posts/2024-03-13-AcWing_896
title: AcWing_896 最长上升子序列II(贪心+二分)
tags: 算法竞赛
---

## AcWing

####  896. 最长上升子序列II

当已经确定序列的结尾元素，考虑确定长度的前驱序列，假设一个前驱序列的最后一个元素为`a`，另一个前驱序列的最后一个元素为`b`，且有`a <= b`，如果`b`对应的前驱序列能作为这个结尾元素的前驱序列，那么`a`对应的前驱序列一定也能作为这个结尾元素的前驱序列。`a`对应的前驱序列是更优的。

不妨维护一个数组`q[N]`，其中的任意一个元素`q[i]`表示序列长度为`i`对应所有可能的结尾元素最小值。可证`q[i]`是严格单调递增的。因为如果`q[i]>=q[i+1]`，那么对于`q[i+1]`的前`i`个元素组成的序列，其结尾元素一定`<q[i+1]<=q[i]`，此时`q[i]`就不是序列长度为`i`对应所有可能的结尾元素最小值了。或者这样理解：序列长度为`i`的最小值是`q[i]`，序列长度为`i+1`，其结尾元素至少也是在`q[i]`的基础上加上一个更大的元素，所以一定有`q[i+1]>q[i]`.

那么，对于数组元素`a[i]`，只需取得数组`q[N]`中恰好**小于**`a[i]`的位置`k`(利用二分的方式)，那么其最大的序列长度就是`k+1`，同时，每取一个数，都要动态更新数组`q[N]`中的`q[k+1]`.

算法的时间复杂度为$O(n(遍历数组a)*logn(二分))$.

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
const int N = 100010;
int a[N], q[N];
int main(){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    int len = 0;    // 全局最大单调序列长度
    q[0] = (int)-2e9;
    for(int i = 1; i <= n; i++){
        int l = 0, r = len;
        while(l < r){
            int mid = l + r + 1 >> 1;
            if(q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
    cout << len << endl;
    return 0;
}
```
