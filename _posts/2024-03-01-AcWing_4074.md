---
redirect_from: /_posts/2024-03-01-AcWing_4074
title: AcWing_4074 铁路与公路(floyd)
tags: 算法竞赛
---

## AcWing

####  4074. 铁路与公路

`floyd`算法，模板。一个可以注意到的事实是，无论是公路还是铁路，从起点到终点一定有一条路线，所以从起点到终点的最长时间即为另一条路线的时间(如果存在)。即，$res = \max{(route_t, route_g)}$，其中，$route_t = 1\quad or \quad route_g = 1$. 路线的时间可以通过`floyd`/`dijkstra`/`SPFA`求得。

`Floyd`:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
const int N = 410, INF = 0x3f3f3f3f;
int t[N][N], g[N][N];
int floyd(int d[][N]){
    if(d[1][N] == 1) return 1;
    for(int k = 1; k <= n; k++){
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                if(i != j && d[i][k] + d[k][j] < d[i][j]){
                    d[i][j] = d[i][k] + d[k][j];
                }
            }
        }
    }
    return d[1][n];
}
int main(){
    cin >> n >> m;
    memset(t, INF, sizeof t);
    memset(g, INF, sizeof g);
    while(m--){
        int u, v;
        cin >> u >> v;
        t[u][v] = t[v][u] = 1;
    }
    for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++) if(i != j && t[i][j] != 1) g[i][j] = 1;
    int res = max(floyd(t), floyd(g));
    if(res >= INF) res = -1;
    cout << res << endl;
    return 0;
}
```
